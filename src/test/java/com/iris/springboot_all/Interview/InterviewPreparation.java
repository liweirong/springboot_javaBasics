package com.iris.springboot_all.Interview;


import java.util.HashMap;
import java.util.LinkedList;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 经典面试题复习
 * @author iris
 * @date 2019/4/23
 */
public class InterviewPreparation {
    public static void main(String[] args) {
        System.out.println(fic(10));
        ant();
    }

    /*
     * N阶楼梯上楼问题：一次可以走两阶或一阶，问有多少种上楼方式
     *
     * 走到第n阶时可能是从第n-1阶走一步到的，也可能是从n-2阶走两阶到的，
     * 设F(n)为走到n阶的种数，则F(n)=F(n-1)+F(n-2)。
     * 当n=1时，F(1)=1，n=2时，F(2)=2,这是一个动态规划问题。其实就是一个斐波那契数列。
     */
    private static int fic(int n) {
        if (n == 1 || n == 2) {
            return n;
        } else if (n >= 3) {
            return fic(n - 1) + fic(n - 2);
        } else {
            return -1;//输入n值非法
        }
    }

    /**
     * 蚂蚁金服 - 电话面试
     * lucene的优化
     * elasticSearch 分布式
     * HashMap的一个理解
     * Java 1.7 中，HashMap 的实现方法是【数组 + 链表】的形式。数组中的每个元素，都是链表的第一个结点。即如下图所示：
     *     1.7到1.8优化了什么？-   1.在 Java 1.8 中，如果链表的长度超过了 8 ，那么链表将转化为红黑树；
     *                           2.发生 hash碰撞时，Java 1.7会在链表头部插入，而Java 1.8 会在链表尾部插入；
     *      扩容：多线程同时增加扩容的话会发生什么？ --死锁
     *          为啥会死锁？
     */

    private static void ant(){
        HashMap<String,String> hs = new HashMap<>();
        hs.put(null,"asdas");
        hs.put(null,"111");
        System.out.println(hs.get(null));
    }

    /**
     * 万师傅面试
     * 设计模式 -
     *      java io涉及到的设计模式 - 适配器模式，装饰器模式
     *
     *      做过那些SQL调优
     *      索引越多越好吗？ --
     *          优化查询效率，主要原则就是应尽量避免全表扫描，应该考虑在where及order by 涉及的列上建立索引
     *          一个表的索引不是越多越好，也没有一个具体的数字，根据以往的经验，一个表的索引最多不能超过6个，因为索引越多，对update和insert操作也会有性能的影响，涉及到索引的新建和重建操作。
     *
     * maven的生命周期
     * 二、构建生命周期是由阶段组成的：
             *
             * 这些构建生命周期中的每一个由构建阶段的不同列表定义，其中构建阶段表示生命周期中的阶段。
             * 例如，默认（default）的生命周期包括以下阶段（注意：这里是简化的阶段，用于生命周期阶段的完整列表，请参阅下方生命周期参考）：
             * 验证（validate） - 验证项目是否正确，所有必要的信息可用
             * 编译（compile） - 编译项目的源代码
             * 测试（test） - 使用合适的单元测试框架测试编译的源代码。这些测试不应该要求代码被打包或部署
             * 打包（package） - 采用编译的代码，并以其可分配格式（如JAR）进行打包。
             * 验证（verify） - 对集成测试的结果执行任何检查，以确保满足质量标准
             * 安装（install） - 将软件包安装到本地存储库中，用作本地其他项目的依赖项
             * 部署（deploy） - 在构建环境中完成，将最终的包复制到远程存储库以与其他开发人员和项目共享。
             * 这些生命周期阶段（以及此处未显示的其他生命周期阶段）依次执行，以完成默认生命周期。给定上述生命周期阶段，这意味着当使用默认生命周期时，Maven将首先验证项目，然后尝试编译源代码，运行这些源代码，打包二进制文件（例如jar），运行集成测试软件包，验证集成测试，将验证的软件包安装到本地存储库，然后将安装的软件包部署到远程存储库。
             *换句话说，在生命周期里面阶段是连续的，在不出错的前提下，比如执行打包（package）时就一定是执行了测试（test）之后再执行
     B树：有序数组+平衡多叉树；
     B+树：有序数组链表+平衡多叉树；
     mysql优化了哪些？
     只对WHERE和ORDER BY需要查询的字段设置索引，避免无意义的硬盘开销；
     ⑵组合索引支持前缀索引；
     ⑶更新表的时候，如增删记录，MySQL会自动更新索引，保持树的平衡；因此更多的索引意味着更多的维护成本
        去掉多余的索引，对一些字段为空的加上默认值，explain分析慢sql，不走索引的情况进行优化比如like“%--%“、<、
        联合索引又叫复合索引。对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。
        例如索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。
     */
    public void wanShiFu(){

    }

    /**
     * 天狼面试
     * hashMap的理解
     *    Java 1.7 中，HashMap 的实现方法是【数组 + 链表】的形式。数组中的每个元素，都是链表的第一个结点。即如下图所示：
     *           1.7到1.8优化了什么？-   1.在 Java 1.8 中，如果链表的长度超过了 8 ，那么链表将转化为【红黑树】；
     *                                       -- 【红黑树】是一种特定类型的二叉树，它是在计算机科学中用来组织数据比如数字的块的一种结构。
     *                                       -- 所有数据块都存储在节点中。这些节点中的某一个节点总是担当起始位置的功能，它不是任何节点的儿子，
     *                                       -- 我们称之为根节点或根。它有最多两个"儿子"，都是它连接到的其他节点。
     *                                       -- 所有这些儿子都可以有自己的儿子，以此类推。这样根节点就有了把它连接到在树中任何其他节点的路径。
     *                                       -- 如果一个节点没有儿子，我们称之为叶子节点，因为在直觉上它是在树的边缘上。子树是从特定节点可以延伸到的树的某一部分，其自身被当作一个树。在红黑树中，叶子被假定为 null 或空。
     *                                       -- 由于红黑树也是二叉查找树，它们当中每一个节点的比较值都必须大于或等于在它的左子树中的所有节点，并且小于或等于在它的右子树中的所有节点。这确保红黑树运作时能够快速的在树中查找给定的值。
     *                                 2.发生 hash碰撞时，Java 1.7会在链表头部插入，而Java 1.8 会在链表尾部插入；
     *      红黑树和avl树类似，都是在进行插入和删除操作时通过特定的操作保持二叉树的平衡，从而获得较高的查找性能。
     *      在java中TreeSet，TreeMap底层通过红黑树（Red-Black tree）实现，也就意味着containsKey(), get(), put(), remove()都有着log(n)的时间复杂度。其具体算法实现参照了《算法导论》。
     *  mybatis的缓存？
     *      正如大多数持久层框架一样，MyBatis 同样提供了一级缓存和二级缓存的支持
     *          一级缓存: 也就Session级的缓存(默认开启)--基于PerpetualCache 的 HashMap本地缓存，其存储作用域为 Session
     *          二级缓存，在userMapper.xml文件中添加如下配置 --机制和一级缓存一样存储作用域为Mapper(Namespace)并且可自定义存储源，
     *          ```
     *              <mapper namespace="me.gacl.mapping.userMapper">
     *              <!-- 开启二级缓存 -->
     *              <cache/>
     *              <cache<!--常用属性-->
     *                  eviction="FIFO"  <!--回收策略为先进先出-->
     *                  flushInterval="60000" <!--自动刷新时间60s-->
     *                  size="512" <!--最多缓存512个引用对象-->
     *                  readOnly="true"/> <!--只读-->
     *              使用二级缓存时，User类必须实现一个Serializable接口===> User implements Serializable
     *                  1. 映射语句文件中的所有select语句将会被缓存。
     *                  2. 映射语句文件中的所有insert，update和delete语句会刷新缓存。
     *                  3. 缓存会使用Least Recently Used（LRU，最近最少使用的）算法来收回。
     *                  4. 缓存会根据指定的时间间隔来刷新。
     *                  5. 缓存会存储1024个对象
     *          ```
     *           对于缓存数据更新机制，当某一个作用域(一级缓存Session/二级缓存Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被clear。
     *  spring aop ioc
     * ***************天照面试
     *  ArrayList, LinkedList, Vector, Stack是List的4个实现类。
     * 　　ArrayList 是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。
     * 　　LinkedList 是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率低，但随机插入、随机删除效率低。
     * 　　Vector 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。但是ArrayList是非线程安全的，而Vector是线程安全的。
     * 　　Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。
     *
     * redis缓存击穿，雪崩? https://baijiahao.baidu.com/s?id=1619572269435584821&wfr=spider&for=pc
     *      [缓存穿透]：缓存穿透，是指查询一个数据库一定不存在的数据。正常的使用缓存流程大致是，数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存。
     *              想象一下这个情况，如果传入的参数为一个一定不存在的对象。就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存。假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。即便是采用UUID，也是很容易找到一个不存在的KEY，进行攻击。
     *          <解决/>：如果从数据库查询的对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒！
     *
     *      [缓存击穿]：是指一个【key非常热点】“爆款”，在不停的扛着大并发，大并发集中对这一个点进行访问，
     *           当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。
     *          <解决/>:其实，大多数情况下这种爆款很难对数据库服务器造成压垮性的压力。达到这个级别的公司没有几家的。让缓存永不过期。即便某些商品自己发酵成了爆款，也是直接设为永不过期就好了。
     *
     *      [雪崩]：缓存雪崩，是指在某一个时间段，缓存集体过期失效。
     *          这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。
     *          而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。
     *          <解决/>:小编在做电商项目的时候，一般是采取不同分类商品，缓存不同周期。在同一分类中的商品，加上一个随机因子。这样能尽可能分散缓存过期时间，而且，热门类目的商品缓存时间长一些，冷门类目的商品缓存时间短一些，也能节省缓存服务的资源。
     *
     *  redis哨兵模式？
     *      Sentinel(哨兵)进程是用于监控redis集群中Master主服务器工作的状态，
     *      在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换，保证系统的高可用，其已经被集成在redis2.6+的版本中，Redis的哨兵模式到了2.8版本之后就稳定了下来。一般在生产环境也建议使用Redis的2.8版本的以后版本。
     *     哨兵模式的优缺点
     *          优点：
     *              1、哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有。
     *              2、主从可以切换，故障可以转移，系统可用性更好。
     *              3、哨兵模式是主从模式的升级，系统更健壮，可用性更高。
     *           缺点：
     *               1、Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。
     *
     *  为啥要用消息队列？
     *          这个问题,咱只答三个最主要的应用场景(不可否认还有其他的，但是只答三个主要的),即以下六个字:
     *              (1)解耦
     *              (2)异步
     *              (3)削峰
     *  消息队列保证消息不丢? - -生产者和消费者
     *      电商的话不能重复的消费
     *  微服务的好处和缺点？
     *          - 简化开发
     *          - 缺点：通信，http请求速度慢，通常一个操作可能会涉及到多个微服务的相互调用，如果为了完成一个操作而多次从服务端调用不同的微服务，http请求的耗时可能会成为瓶颈，如图1所示。
     * RPC？（Remote Procedure Call，远程过程调用）RPC主要是基于TCP/IP协议的
     * 关系型和非关系的区别？
     *      关系型是有关系的，比如外键这种，需要定义表结构，非关系型的数据库不需要定义直接开始
     *
     */
    public void HashMap() {
        HashMap<String,String>  map =  new HashMap<>();
        map.put(null,null);
        new HashMap<DataWrap,String>();
        ConcurrentHashMap<Object, Object> objectObjectConcurrentHashMap = new ConcurrentHashMap<>();
        LinkedList<String> strings = new LinkedList<>();
    }

    /**
     * 步步高 。。
     */

    /**
     * 思为软件
     * spring注入？
     * spring注释？
     * mysql的调优？
     * mysql引擎了解吗？---https://www.cnblogs.com/sunsky303/p/8274586.html
     *      InnoDB 、MyIsam 、Memory（也叫HEAP）堆内存嘛、Mrg_Myisam：（分表的一种方式–水平分表）、Blackhole（黑洞引擎）
     *          InnoDB和MyIsam的区别？
     *
     * SpringMVC的理解和流程？
     *      SpringMVC是一种基于Spring实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，使用了MVC架构模式的思想，将web层进行职责解耦，并管理应用所需对象的生命周期，为简化日常开发，提供了很大便利。
     *       org.springframework.web.servlet.DispatcherServlet
     * hashMap的理解？
     * jvm的模型？
     * 线程占用的是什么？
     * spring的设计模式？代理模式？具体到某个类
     * aop？ioc？
     * 切面有那些
     * 通知类型:
     *      前置通知: 目标方法执行之前
     *      后置通知: 目标方法执行之后
     *      异常通知: 目标方法执行之后抛出异常时执行
     *      最终通知: 目标方法执行之后,最后执行的通知
     *          以上通知记录程序执行状态
     *      环绕通知: 目标方法执行之前之后都要执行。环绕通知能控制目标方法执行
     * spring事务传播有哪几种？
     * sql调优explain主要看的参数？
     *
     * redis的一些数据类型？
     *      string(字符串)、
     *      list(链表)、
     *      set(集合)、
     *      zset(sorted set --有序集合)、
     *      hash（哈希类型）
     *
     * zookeeper用来干嘛？
     *  kafka等一些用来选主
     *
     * kafka的底层了解吗？
     * jvm调参调了哪些？
     * spring的注入方式？
     *      spring的依赖注入分为三种方式
     *          1.构造器注入
     *          2.setter注入
     *          3.接口注入
     * 可以注入构造函数吗？
     *
     */

}
