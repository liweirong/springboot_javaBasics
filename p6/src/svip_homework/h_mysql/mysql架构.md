## 缓冲池 buffer pool

*innodb设定了一个存储引擎从磁盘读取数据到内存的最小单位：**页***       （一页=16k)

缓冲池的出现是为了减少与磁盘的交互

### 修改内存已有数据逻辑

比如update id=5的数据 我们发现在buffer pool里面已经有这条数据了。只需要更改内存的数据页即可，而这个被更改的页也就叫做**脏页**（因为跟我磁盘的数据不一致了）。
既然不一致了，那我们还需要把内存更改过的数据同步到磁盘，那么这个动作就叫做**刷脏**。

* 那么刷脏的时候怎么找到我的脏页？

```text
这些脏页会在我们buffer pool里面有一个专门的脏页链表，叫做flush链表。这样我去找我的脏页只要去这个链表找就行，不需要在我内存的所有的页面里面去找了。
```

* 那么刷脏什么时候进行？

```text
  最简单的办法，我每次更改，更改内存的同时，我立即同步到磁盘！！但是磁盘慢得跟乌龟一样，会严重影响程序的性能，所以我们不立即同步给磁盘；
  我们有自己的一些刷脏模式我们有专门的线程每隔一段时间就把脏页刷新到磁盘，不影响用户线程正常的请求操作。这些线程叫做Page Cleaner，可以配置线程数量。
  innodb-page-cleaners刷脏的模式也有很多，比如
  * 基本模式 根据redo产生的速度来决定
  * 脏页自适应 根据Redo的产生速度和脏页的使用比例共同来决定刷脏速度。
  * 通过innodb_max_dirty_pages_pct_lwm和innodb_max_dirty_pages_pct来控制Redo自适应模式 根据Redo的产生速度和Redo的使用比例共同来决定刷脏速度。通过innodb_adaptive_flushing和innodb_adaptive_flushing_lwm参数控制
  * 空闲模式 等等
```

**Double Write机制**

```text
操作数据都是一页一页的操作的，一页里面有很多很多的数据。
  那么假如，我一个页里面有些成功，有些失败，那怎么办！！所以，为了保证页的数据一致性，又有了 Double Write的机制 
1.在刷盘覆盖磁盘的时候，我们会将page内容写入到磁盘的另外一个地方，叫做double write buffer。 
2.然后再把内存里面的数据同步到磁盘 如果第一步失败，原来的数据没有覆盖，数据页是完整的 如果第二步失败，原来的数据不完整，
但是double write buffer是完整的， 可以用double write buffer里面的覆盖 以上是我们去修改一条在buffer pool中有的数据，但是如果我改一条 buffer pool里面没有的数据咋办？是不是需要从磁盘读出来？ 其实我们也不需要从磁盘里面读取出来，而是在buffer
  pool的内存空间里 面又分了一块出来，叫做change buffer，可以通过参数 innodb_change_buffer_max_size来动态设置，这个参数为50的时候，标 识change buffer 的大小最多只能占用
  buffer pool的50%。 
  1.首先记录到redo Log中，防止机器意外关闭导致数据丢失，会同时写到 redo log buffer与redo文件磁盘；写成功返回给客户成功。
  我们也将更新的操作记录到change_buffer，降低跟磁盘的随机IO
 
```

* 那么change_buffer里的数据怎么更新到磁盘？

```text
1.系统有后台线程定期执行合并操作，数据库正常关闭也会进行合并
2.当下次查询命中这个数据页的时候。会先从磁盘读取到数据页到内存，执 行合并操作，然后再返回结果给用户，保证结果的正确
```

* 是不是所有的数据都会用到change Buffer？

```text
因为唯一索引每个插入或者更新都要判断是否违反唯一约束，所以每次更 新都要从内存中找到这个记录对应的数据页，没有的话需要从磁盘中读出，
反正都要从磁盘读数据页了，还不如直接更新内存/磁盘，那么也就意 味着change buffer失去意义，所以唯一索引使用change buffer 的话反倒会降低效率，
所以只有普通索引能使用到change buffer。
如果不用索引，那么buffer pool都不能用，直接操作磁盘！不然整个表放到内存，内存就爆了！！
二级索引
```

* 那么什么场景下是否使用change Buffer？

```text
  当写少读多的情况下：change buffer的利用率不高，因为可能刚一更新完可能就需要查询、就触发merge操作，change
  buffer没有起到减少随机IO，还多了一个维护change buffer的成本。 当写多读少的情况下：change buffer的提升效果较明显，可能很多条更新后，也没有一个查询线程来触发merge操作，可以大幅减少磁盘的随机IO。
```
