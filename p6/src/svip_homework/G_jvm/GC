

# 哪些对象可以作为GC Roots呢？以Java为例，有以下几种：
    1、栈（栈帧中的本地变量表）中引用的对象。
    2、方法区中的静态成员 静态属性引用的对象。
    3、方法区中的常量引用的对象（全局变量）。
    4、本地方法栈中JNI（一般说的Native方法）引用的对象。
    5、活跃线程的引用对象。
    6 类加载器
    注：第一和第四种都是指的方法的本地变量表，第二种表达的意思比较清晰，第三种主要指的是声明为final的常量值。\
GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。
    1.虚拟机栈中引用的对象（即栈帧中的本地变量表）
    2.方法区中的常量引用的对象
    3.方法区中的类静态属性引用的对象
    4.本地方法栈中的JNI(Native方法)的引用对象
    5.活跃线程的引用对象



# 各代怎么清理垃圾？
新生代：复制清理；
老年代：标记-清除和标记-压缩算法
永久代：存放Java中的类和加载类的类加载器本身

# Minor GC、Major GC、Full GC
Minor GC: 从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。
Major GC: 是清理老年代。
Full GC : 是清理整个堆空间—包括年轻代和老年代。
    很不幸，实际上它还有点复杂且令人困惑。首先，许多 Major GC 是由 Minor GC 触发的，所以很多情况下将这两种 GC 分离是不太可能的。


# 保守式GC与准确式GC
1、保守式GC
       所谓保守式GC就是“不能识别指针和非指针的GC”。
       对于寄存器、调用栈、全局变量空间来说，都是不明确的根。例如调用栈中，装着函数内的局部变量和参数值。而局部变量，如C语言中的int、double这样就是非指针，但是也会有像void*这样的指针。
       那么保守式GC会怎么检查不明确的根呢？1、是不是被正确对齐的值？（在32位CPU的情况下，为4的倍数）2、是不是指着堆内？3、是不是指向对象的开头？当然，这些只是基本的检查项目。
       上面的检查方法会将一些非指针识别成指针。例如一个数值和一个地址，它们两个值相等，这个时候，那个值也可以被识别成指针。
       保守式GC的优点是语言处理程序不依赖与GC。缺点为识别指针和非指针需要付出成本、错误识别指针会压迫堆、能够使用的GC算法有限。例如GC复制算法就不能使用，因为其可能会将非指针重写。
2、准确式GC
       准确式GC能够正确识别指针和非指针的GC。正确的根的创建方法是依赖于语言处理程序的实现的。我们可以通过打标签、不把寄存器和栈等当作根的方法来实现。
       其优点就是完全能够识别指针，能够使用复制算法等需要移动对象的算法。但是在创建准确式GC时，语言处理程序必须对GC进行一些支援，而且创建正确的根就必须付出一定的代价。



标记-清除算法
    标记阶段和清除阶段。
    一种可行的方式是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象，因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。
    缺点： 1 标记清除算法回收后的控件时不连续的，会产生空间碎片，在对象的堆空间分配过程中，尤其是大对象的分配，不连续内存空间的工作效率要低于连续的空间
复制算法
    Java中新生代采用 s0 s1
    优点：1 复制算法的效率是很高的；2 新的内存空间中可以保证是没有内存碎片的。
    缺点: 1 复制算法的代价是将系统内存折半，一般情况下很难让人接受；2 对于存活对象较多的情况，效率不能保证

标记-压缩算法
    Java中老年代采用
    标记-压缩算法与标记-清理算法类似，只是后续步骤是让所有存活的对象移动到一端，然后直接清除掉端边界以外的内存。
    该算法可以有效的利用堆，但是压缩需要花比较多的时间成本，在标记对象相对较少的时候，效率较高


# 常见垃圾回收器
G1
ZGC jdk11 号称可以达到10ms 以下的 GC 停顿


Stop-The-World会挂起应用线程，造成应用的停顿。


新生代收集器
     Serial收集器 ：作用于新生代，是一个单线程收集器，基于复制算法实现。在进行垃圾回收的时候仅使用单条线程并且在回收的过程中会挂起所有的用户线程(Stop The World)。Serial收集器是JVM client模式下默认的新生代收集器。
     ParNew收集器 ：作用于新生代，是一个多线程收集器，基于复制算法实现。相对于Serial收集器而言，在垃圾回收的时候会同时使用多条线程进行回收，但是它跟Serial收集器一样，在回收过程中也是会挂起所有的用户线程，从而造成应用的停顿。
     Parallel Scavenge收集器：作用于新生代，并且也是采用多线程和复制算法来进行垃圾回收。Parallel Scavenge收集器关注的是吞吐量，即使得应用能够充分使用CPU。它与ParNew收集器一样，在回收过程会挂起所有的用户线程，造成应用停顿。
            所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。即吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。如果虚拟机运行了100分钟，其中垃圾收集花了1分钟，那么吞吐量就是99%。

老年代收集器
     Serial Old收集器：作用于老年代，采用单线程和标记-整理算法来实现垃圾回收。在回收垃圾的时候同样会挂起所有用户线程，造成应用的停顿。一般来说，老年代的容量都比新生代要大，所以当发生老年代的垃圾回收时，STW经历的时间会比新生代所用的时间长得多。该收集器是JVM client模式下默认的老年代收集器。
                   Serial Old收集器还有一个重要的用途是作为CMS收集器的后备方案，在并发收集发生Concurrent Mode Failure的时候使用，进行内存碎片的整理。
     Parallel Old收集器：Parallel Old收集器是Parallel Scavenge收集器的老年代版本，采用多线程和标记-整理算法来实现老年代的垃圾回收。这个收集器主要是为了配合Parallel Scavenge收集器的使用，即当新生代选择了Parallel Scavenge收集器的情况下，老年代可以选择Parallel Old收集器。
        在JDK1.6以前并没有提供Parallel Scavenge收集器，所以在1.6版本以前，Parallel Scavenge收集器只能与Serial Old收集器搭配使用。
     CMS收集器：CMS(Concurrent Mark Sweep)收集器是一款真正实现了并发收集的老年代收集器。CMS收集器以获取最短回收停顿时间为目标，采用多线程并发以及标记-清除算法来实现垃圾回收。CMS只在初始化标记和重新标记阶段需要挂起用户线程,造成一定的应用停顿(STW)，而其他阶段收集线程都可以与用户线程并发交替进行，不必挂起用户线程，所以并不会造成应用的停顿。CMS收集器可以最大程度地减少因垃圾回收而造成应用停顿的时间。



CMS垃圾收集分为以下几个阶段(重点四部)：
    (1) 初始化标记 (inital mark) 这个阶段仅仅是标记了GC Roots能够直接关联到的对象，速度很快，所以基本上感受不到STW带来的停顿。
    (2) 并发标记 (concurrent mark) 并发标记阶段完成的任务是从第一阶段收集到的对象引用开始，遍历所有其他的对象引用，并标记所有需要回收的对象。这个阶段，收集线程与用户线程并发交替执行，不必挂起用户线程，所以并不会造成应用停顿。
         (3) 并发预清除 (concurrent-pre-clean) 并发预清除阶段是为了下一个阶段做准备，为的是尽量减少应用停顿的时间。
    (4) 重新标记 (remark) 这个阶段将会修正并发标记期间因为用户程序继续运作而导致标记产生变动的那部分对象的标记记录(有可能对象重新被引用或者新对象可以被回收)。这个阶段的停顿时间比初始标记阶段要长一些，但是远比并发标记的时间短。
    (5) 并发清除 (concurrent sweep) 这个阶段将真正执行垃圾回收，将那些不被使用的对象内存回收掉。
         (6) 并发重置 (concurrent reset) 收集器做一些收尾的工作，以便下一次GC周期能有一个干净的状态。
优点:并发效率高,标记过程和清除过程时并发停顿短|   初始化标记&重新标记 stw
缺点:
使用CMS要注意以下两个关键词：
concurrent mode failure
promotion failed
对于采用CMS进行老年代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。promotion failed是在进行Minor GC时，新生代的survivor区放不下,对象只能放入老年代，而此时老年代也放不下造成的。concurrent mode failure是在执行CMS GC的过程中同时有对象要放入老年代(满足一定年龄的对象或者大对象)，而此时老年代空间不足造成的。
通常我们把发生在新生代的垃圾回收称为Minor GC，而把发生在老年代的垃圾回收称为Major GC，而FullGC是指整个堆内存的垃圾回收，包括对新生代、老年代和持久代的回收。一般情况下应用程序发生Minor GC的次数要远远大于Major GC和Full GC的次数。
在讲解GC的时候会涉及到并行和并发两个概念。在这里，并行指的是多个GC收集线程之间并行进行垃圾回收。而并发指的是多个GC收集线程与所有的用户线程能够交替执行。

# GC日志
 -XX:+PrintGCDateStamps