1 请说下JMM内存模型（语音作业）<br/>
2 请说下你对volatile的理解（语音作业）<br/>
3 什么是happens-before模型，包含了哪些规则（语音作业）<br/>

1 请说下JMM内存模型（语音作业）

```text
java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。
从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，
每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。
不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成
本地内存是JMM的一个抽象概念，并不真实存在


线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量
（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。
局部变量（Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）
不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。
线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证
```

2 请说下你对volatile的理解（语音作业）<br/>

```text

简而言之，volatile变量自身具有下列特性。
·可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入；
    结合jmm来讲就是（虽然volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。
·有序性：禁止了指令重排；
    例如在双检锁中初始化对象时虽然对象是一行进行创建的，但其实底层指令是三个，可能进行重排序返回空的对象再赋值，
    并发竞争激烈的情况下可能产生多个实例对象，就不叫单例了；有了禁止执行重排返回的对象必然不为空，避免产生多个对象
·不能保证原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性
```

3 什么是happens before模型，包含了哪些规则（语音作业）<br/>

```text
happens-before是JMM定义的2个操作之间的偏序关系,是JMM最核心的概念
首先，让我们来看JMM的设计意图。从JMM设计者的角度，在设计JMM时，需要考虑两个关键因素。
    ·程序员对内存模型的使用。程序员希望内存模型易于理解、易于编程。程序员希望基于一个强内存模型来编写代码。
    ·编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。
    编译器和处理器希望实现一个弱内存模型。
由于这两个因素互相矛盾，所以JSR-133专家组在设计JMM时的核心目标就是找到一个好的平衡点：
        一方面，要为程序员提供足够强的内存可见性保证；
        另一方面，对编译器和处理器的限制要尽可能地放松。
        
JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。

《JSR-133:Java Memory Model and Thread Specification》对happens-before关系的定义如下。
1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。
    如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。
    
    
《JSR-133:Java Memory Model and Thread Specification》定义了如下happens-before规则。
1）程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
2）监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
3）volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
4）传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
5）start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
6）join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。

```