1 请简单说下class文件结构（语音作业）<br>
2 类文件到JVM的加载流程是什么样的？说明下类加载机制有哪些以及加载原则？（语音作业）<br>
3 请你说下对JVM内存模型的理解？（语音作业）<br>

1 请简单说下class文件结构（语音作业）<br>

```text
.java由 javac 编译成.class

Java虚拟机规范规定，Class文件格式采用类似C语言结构体的伪结构来存储数据，这种结构只有两种数据类型：无符号数和表
    1，无符号数，以u1、u2、u4、u8分别代表1个字节、2个字节、4个字节、8个字节的无符号数
    2，表，以“_info”结尾，由多个无符号数或其它表构成的复合数据类型

javap -v XXX.class

class文件固定格式：
    magic：魔数，0xCAFEBABE（cafe babe） ： 四个字节称为魔数，它的唯一作用是用来验证该文件是否为一个能被虚拟机接受的Class文件。
            使用魔数而不使用文件扩展名是出于安全方面的考虑，因为文件扩展名可以很随意的被改动
    Class文件的版本号 4个字节的主版本和子版本号
    常量池计数器:   只有常量池的计数是从1开始的，其它集合类型均从0开始
    常量池: 类的常量
    访问标志（2字节）:访问标志 标志了类或者接口的访问信息，比如是类还是接口还是注解、枚举，是否是abstract,如果是类，是否被声明成final等等
    类索引、父类索引和接口索引集合
    字段表集合:
    方法表集合：参数、返回值、异常时的信息
    属性表集合:



```

2 类文件到JVM的加载流程是什么样的？说明下类加载机制有哪些以及加载原则？（语音作业）<br>

```text



通过类加载器进行加载
加载器：
    1) Bootstrap类加载器 – JRE/lib/rt.jar
    2) Extension类加载器 – JRE/lib/ext或者java.ext.dirs指向的目录
    3) Application类加载器 – CLASSPATH环境变量, 由-classpath或-cp选项定义,或者是JAR中的Manifest的classpath属性定义.
    4) 自定义类加载器

类加载机制
1. 全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
2. 双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。
通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
3. 缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，
当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。
这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。




类加载器的工作原理:
    委托:  双亲委派
    可见性: 子类加载器可以看到父类加载器加载的类，而反之则不行
    单一性: 父加载器加载过的类不能被子加载器加载第二次。虽然可破坏这种机制，但这样做并不可取。
自定义的类加载器的时候应该严格遵守这三条机制


加载原则：双亲委派
类加载的时候，会优先递归给父类加载器去加载，父类加载器没有加载的时候才会往下的加载器去进行
    目的：为了安全，保证核心类库的安全性，防止被篡改，以及保证类的唯一
        ClassNotFoundException（加载时找不到类）；NotClassFoundException（编译时找不到类）



打破双亲委派机制： tomcat  webapps下多个项目用到一种jar但不同版本的jar包 ，必须打破双亲委派机制，重写 classLoad findClass接口，不去往上找
```

3 请你说下对JVM内存模型的理解？（语音作业）<br>

```text
JVM内存模型就是我刚刚加载的class文件数据我要加载到JVM，那么这些数据我放在JVM哪里
JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的
Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，

这些数据区域都有各自的用途，以及创建和销毁的时间，并且它们可以分为两种类型：
线程共享的方法区和堆，
线程私有的虚拟机栈、本地方法栈和程序计数器。

* 方法区
* 堆

* 虚拟机栈
* 本地方法栈
* 程序计数器
```