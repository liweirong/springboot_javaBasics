请例举你所知道的Mysql的锁！并做简单说明（语音作业）<br>
为什么innoDB的RR能解决幻读问题（语音作业）<br>
说下你对innoDB事务的理解！事务并发带来什么问题？怎么解决？（语音作业）<br>

请例举你所知道的Mysql的锁！并做简单说明（语音作业）<br>

```text
锁的出现是解决了并发事务对数据的访问问题的
锁分两大类：全局锁、表锁、行锁
全局锁
    - 全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是Flush tables with read lock。当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句
    全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都select出来存成文本
    但是让整个库都只读，可能出现以下问题：
    如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆
    如果在从库上备份，那么在备份期间从库不能执行主库同步过来的binlog，会导致主从延迟
    在可重复读隔离级别下开启一个事务能够拿到一致性视图
    官方自带的逻辑备份工具是mysqldump。
表锁
    - 意向锁 由数据库自己维护，
        意向共享锁 我们在给一行数据加共享锁之前，数据库会自动在表上加一个**意向共享锁**
        意向排他锁 我们在给一行数据加排他锁之前，数据库会自动在表上加一个**意向排他锁**
            是为了在当加表锁的时候，需要去扫描有没有加行锁，如果没有意向锁则会扫全表才能确定，有了意向锁后能直接看到，理解为一个标志
    - 自增锁 特殊的表锁，用来防止自增字段重复，数据插入以后就会释放，不需要等事务提交
行锁（shared and exclusive locks）
    - 共享锁 也叫读锁，会阻塞其他事务的修改 select ...lock in share mode
    - 排他锁 修改数据默认加锁、 手动 ... for update 给一行数据加排他锁
    
在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议

innodb的行锁是通过锁住索引来实现的
    行锁的算法 4 5 6 7 10
        记录锁(record locks)：对于唯一索引进行等值查询的时候会精确匹配到一个记录，这个时候使用的就是记录锁 id = 4 -- [4] 5 6 7 10
            解决不可重复读
        间隙锁(gap locks)：查询记录不存在，没有命中record，无论等值或范围查询都是间隙锁；gap 锁主要阻塞insert  锁住的是左开右开区间 
                id = 4 -- 4 5 6 (7 10)  || id = 11 -- 4 5 6 7 (10 ,无穷)
            解决幻读
            它只会在锁不存在的insert,修改删除不存在的数据是不会锁的
        临键锁(next-key locks)：使用了范围查询，不仅命中了record记录，还包含了gap间隙，这种情况下就是用临建锁，是mysql默认的行锁算法-相当于记录锁加上间隙锁
            临键锁 相当于 记录锁加间隙锁
            等值查询到一条记录的时候退化成记录锁。
            没匹配到任何记录的时候，退化成间隙锁
                 id > 5 and id < 10  -- 4 5 6 7 10
                当存在临界值时，临建锁还会锁住下一个左开右闭区间的区间 ----- 为了解决幻读的问题。
```

为什么innoDB的RR能解决幻读问题（语音作业）<br>

```text
四大隔离级别：
    RU(Read Uncommitted) 未提交读   - [脏读,不可重复读,幻读]
        不加锁
    RC(Read Committed) 已提交读     - [不可重复读,幻读]
        普通的select的快照读 底层使用MVCC实现
        加锁的select都是使用record lock没有gap lock、next ky lock
    RR（Repeatable Read） 可重复读   - [幻读(innodb解决了)]
        普通的select的快照读 底层使用MVCC实现
        加锁的select或者update delete使用的是当前读，底层使用record lock、gap lock、next ky lock
    Serializable 串行化
        所有select语句都会隐式转换为select in share mode共享锁阻塞其他事务的修改，会和update、delete互斥

解决读一致性的问题，总体由两大类方案,innodb采用mvcc解决了RR隔离级别的幻读问题
LBCC（lock Based concurrency Control） 解决写一致性
    读取数据的时候基于锁，去锁住要操作的数据，不允许其他事务修改。如果只是基于锁意味着不支持并发，我们大多数时候都是读多写少，影响效率
MVCC（multi version concurrency control） 多版本并发控制 解决读一致性
    MVCC可以看见这个事务之前已经存在的数据，甚至后面被修改或被删除；在这个事务之后的数据是看不到的，也叫快照
    MVCC是通过 ReadView+ UndoLog 实现的，UndoLog 保存了历史快照，ReadView 规则帮助判断当前版本的数据是否可见。
        如果事务隔离级别是RC ，一个事务的每一次 Select 都会去查一次ReadView ，每次查询的Read View 不同，就可能会造成不可重复读或者幻读的情况。
        如果事务隔离级别是RR，为了避免不可重读读，一个事务只在第一次 Select 的时候会获取一次Read View ，然后后面索引的Select 会复用这个 ReadView.
    原理：
        innodb为每个记录都实现了两个隐藏字段
            - DB_TRX_ID 6字节 【事务ID】 数据是在哪个事务插入或修改为新数据的就记录当前事务ID
            - DB_ROLL_PTR 7字节 【回滚指针（删除版本号）】 数据被删除或记录为旧数据的时候记录当前事务ID 没有修改或删除时候是空
                DB_ROLL_PTR其实是指向undo log链的指针
    MVCC查找规则：只能查找创建时间小于等于当前事务id 和删除时间大于当前事务id的行或者为空（未删除）


ReadView(读视图)
Read View 是啥？
如果一个事务要查询行记录，需要读取哪个版本的行记录呢？ Read View 就是来解决这个问题的。
Read View 可以帮助我们解决可见性问题。 Read View 保存了当前事务开启时所有活跃的事务列表。
换个角度，可以理解为: Read View 保存了不应该让这个事务看到的其他事务 ID 列表。
    trx_ids 系统当前正在活跃的事务ID集合。
    min_trx_id 表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小
    max_trx_id 表示生成ReadView时,系统中应该分配给下一个事务的id值。
    creator_trx_id 创建这个ReadView的事务ID。
规则：
    如果trx_id < 活跃的最小事务ID（up_limit_id）,也就是说这个行记录在这些活跃的事务创建前就已经提交了，那么这个行记录对当前事务是可见的。
    如果trx_id > 活跃的最大事务ID（low_limit_id），这个说明行记录在这些活跃的事务之后才创建，说明这个行记录对当前事务是不可见的。
    如果 up_limit_id < trx_id <low_limit_id,说明该记录需要在 trx_ids 集合中，可能还处于活跃状态，因此我们需要在 trx_ids 集合中遍历 
        1.trx_id 存在于 trx_ids 集合中，证明这个事务 trx_id 还处于活跃状态，不可见，
        2.trx_id 不存在于 trx_ids 集合中，说明事务trx_id 已经提交了，这行记录是可见的。

    假如，在一个事务我开始查询的时候，存活的是[100,101,103]   max_trx_id=104  ,
    然后假如数据的事务102就是不存活的；100<102<104 ，所以需要再去检索一下

已提交读和可重复读的区别就在于它们生成ReadView的策略不同。
   如果事务隔离级别是 ReadCommit ，一个事务的每一次 Select 都会去查一次ReadView ，每次查询的Read View 不同，就可能会造成不可重复读或者幻读的情况。
   如果事务的隔离级别是可重读，为了避免不可重读读，一个事务只在第一次 Select 的时候会获取一次Read View ，然后后面索引的Select 会复用这个 ReadView.

```

```text
innodb的行锁是通过锁住索引来实现的
如果表没有索引，怎么办？
    定义主键会选择主键作为聚集索引
    没有显示的定义会选择包含null的唯一索引作为主键索引
    没有这样的话innodb会内置6字节长的rowid作为隐藏的聚集索引
    
如果加的行锁没有走索引则会锁住全表
```

说下你对innoDB事务的理解！事务并发带来什么问题？怎么解决？（语音作业）<br>

```text
mysql中的innodb是支持事务的
    事务基本要素
       A 原子性 undo log
       C 一致性 
       I 隔离性 隔离级别 每个读写事务的对象对其他事务的操作对象能相互分离
       D 持久化 redo log
事务并发读一致性的问题，也就是说在一个事务中前后两次的查询不一致
事务并发导致的三大问题：
    脏读：一个事务读到了其他事务未提交的数据导致前后两次读取的数据不一致
    不可重复读：一个事务读取到了一条记录时，其他事务进行了更新操作并提交 （修改或删除造成的读不一致）
    幻读：一个事务进行范围查询时，其他事务进行了删除或插入并且提交事务，多冒出来数据，造成事务中两次查询数据不一致（插入造成的读不一致）

读一致性是靠数据库的隔离级别来解决的


如果事务隔离级别是RC ，一个事务的每一次 Select 都会去查一次ReadView ，每次查询的Read View 不同，就可能会造成不可重复读或者幻读的情况。
如果事务隔离级别是RR，为了避免不可重读读，一个事务只在第一次 Select 的时候会获取一次Read View ，然后后面索引的Select 会复用这个 ReadView.

TransactionID：DB_TRX_ID，记录操作该数据事务的事务ID
RollPointer：DB_ROLL_PTR，指向上一个版本数据在undo log 里的位置指针

sql92定义了隔离级别
    
```
