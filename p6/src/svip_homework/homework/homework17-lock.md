1 请看完reentrantlock源码后，画出整个reentrantlock的执行流程逻辑图<br>
2 请说下你对aqs的理解（语音作业）<br>
3 请说下公平锁与非公平锁的区别（语音作业）<br>

请看完reentrantlock源码后，画出整个reentrantlock的执行流程逻辑图

```text
 https://www.processon.com/diagraming/618bf17f637689783e2a485f
```

2 请说下你对aqs的理解（语音作业）

```text
AQS（AbstractQueuedSynchronizer）就是抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它,
AQS是一个Java提供的底层同步工具类，。
1 AQS内部用一个volatile修饰的int类型的state变量表示同步状态，并提供了一系列的CAS操作来管理这个同步状态。
2 AQS内部还有一个关键变量exclusiveOwnerThread，用来记录当前加锁的是哪个线程;
3 AQS内部有个FIFO的阻塞队列，竞争失败的情况下会将自己放入其中;

AQS的主要作用是为Java中的并发同步组件提供统一的底层支持，如常用的ReentrantLock/Semaphore/CountDownLatch/SyclicBarrier等就是基于AQS实现的，
用法是通过继承AQS实现其模版方法，然后将子类作为同步组件的内部类。

一句话概括：
AQS是由一个volatile修饰的state和监控这个state的双向链构成，双项链每个节点是一个Node，每一个Node封装了一个线程；
通过tryAcquire（）、compareAndSetSate(）来获取锁；

AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现（通过state的get/set/CAS）。
至于能不能重入，能不能阻塞，那就看具体的自定义同步器怎么去设计了;例如ReentrantLock的AQS的两个实现类能实现公平和非公平锁

```

3 请说下公平锁与非公平锁的区别（语音作业）

```text
公平锁首先从名字就能得出，能保证每个线程顺序执行的公平机制
非公平就是不能保证公平，就是时常有人插队
为什么要设计这些呢？首先公平锁是保证比如抢红包这种业务有个先来后到
当业务不在乎谁先谁后时采用非公平锁会效率高点，因为线程不用强制挂起，不公平的点在于后面的线程需要多等待会

非公平锁
    优点：可以减少线程切换的开销，其实就是非公平锁效率高于公平锁的原因，因为非公平锁减少了线程挂起的几率，后来的线程有一定几率逃离被挂起的开销，而公平锁一定会挂起。
    缺点：这样总是插队可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。

公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。
    优点：所有的线程都能得到资源，不会饿死在队列中。
    缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大
```

ReentrantLock为什么要有两个condition（条件唤醒）
```text
为了性能
生产者 --唤醒 --消费者
不止一个生产者消费者

生产者只会唤醒消费者
消费者只会唤醒生产者
```