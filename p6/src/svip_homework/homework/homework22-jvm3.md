1 JVM内存中为什么会有新生代，老年代，新生代为什么有Eden跟Survivor?Survivor又有S0、S1?（语音作业） 2 请描述下JVM中的垃圾回收算法与垃圾回收器，各回收器的场景以及区别（语音作业） 3
怎么去判断一个对象能够进行GC回收？（语音作业）

## 1 JVM内存中为什么会有新生代，老年代，新生代为什么有Eden跟Survivor?Survivor又有S0、S1?（语音作业）

```text

1 如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，
    进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。
2.Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。
3.设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次MinorGC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；
    等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1
   （这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）。
```

## 2 请描述下JVM中的垃圾回收算法与垃圾回收器，各回收器的场景以及区别（语音作业）

```text
算法
复制算法: 申请两块大小一样的内存空间,标记出存活对象复制到另一块内存 比如eden区的s0和s1
    缺点：浪费了空间；因为要进行对象复制，所以效率也不高
标记清除算法:先对垃圾进行标记,在进行清除
    缺点：1）会产生空间碎片 2）标记和清除过程效率比较低
标记整理算法
    缺点：要对对象进行迁移，所以效率也不高
分代收集算法
    它并没有任何的数学创新，它是应用创新,将上面的三种不同算法分别用在了不同的区域中
    新生代对象的特点：朝生夕死
    复制算法适用于新生代,因为需要存活的对象少所以复制的对象就少
    标记整理,标记清除算法适用于老年代

垃圾回收器
Serial 

```

## 3 怎么去判断一个对象能够进行GC回收？（语音作业）

```text
判断哪些对象需要被回收
有以下两种方法：

引用计数法(python)
    给对象添加一引用计数器，被引用一次计数器值就加 1；当引用失效时，计数器值就减 1；计数器为 0 时，对象就是不可能再被使用的，简单高效，缺点是无法解决对象之间相互循环引用的问题。
可达性分析算法 - GC Roots
    通过一系列的称为 "GC Roots" 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），
    当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。此算法解决了上述循环引用的问题。
    
    在Java语言中，可作为 GC Roots 的对象包括下面几种：
        a. 虚拟机栈（栈帧中的本地变量表）中引用的对象。
        b. 方法区中类静态属性引用的对象。
        c. 方法区中常量引用的对象。
        d. 本地方法栈中 JNI（Native方法）引用的对象

作为 GC Roots 的节点主要在全局性的引用与执行上下文中。要明确的是，tracing gc必须以当前存活的对象集为 Roots，因此必须选取确定存活的引用类型对象。
GC 管理的区域是 Java 堆，虚拟机栈、方法区和本地方法栈不被 GC 所管理，因此选用这些区域内引用的对象作为 GC Roots，是不会被 GC 所回收的。
其中虚拟机栈和本地方法栈都是线程私有的内存区域，只要线程没有终止，就能确保它们中引用的对象的存活。而方法区中类静态属性引用的对象是显然存活的。常量引用的对象在当前可能存活，因此，也可能是 GC roots 的一部分。
```