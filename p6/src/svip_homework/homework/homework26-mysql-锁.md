请例举你所知道的Mysql的锁！并做简单说明（语音作业）<br>
为什么innoDB的RR能解决幻读问题（语音作业）<br>
说下你对innoDB事务的理解！事务并发带来什么问题？怎么解决？（语音作业）<br>

请例举你所知道的Mysql的锁！并做简单说明（语音作业）<br>

```text
锁的出现是解决了并发事务对数据的访问问题的
锁分两大类：行锁、表锁
表锁
    - 意向锁 由数据库自己维护，
        我们在给一行数据加共享锁之前，数据库会自动在表上加一个意向共享锁
        我们在给一行数据加排他锁之前，数据库会自动在表上加一个意向排他锁
        是为了在当加表锁的时候，需要去扫描有没有加行锁，如果没有意向锁则会扫全表才能确定，有了意向锁后能直接看到，理解为一个标志
    - 自增锁 特殊的表锁，用来防止自增字段重复，数据插入以后就会释放，不需要等事务提交
行锁（shared and exclusive locks）
    - 共享锁 也叫读锁，会阻塞其他事务的修改 select ...lock in share mode
    - 排他锁 修改数据默认加锁、 手动 ... for update 给一行数据加排他锁
    


innodb的行锁是通过锁住索引来实现的
    行锁的算法 4 5 6 7 10
        记录锁(record locks)：对于唯一索引进行等值查询的时候会精确匹配到一个记录，这个时候使用的就是记录锁 id = 4 -- [4] 5 6 7 10
        间隙锁(gap locks)：查询记录不存在，没有命中record，无论等值或范围查询都是间隙锁；gap 锁主要阻塞insert  锁住的是左开右开区间 
                id = 4 -- 4 5 6 (7 10)  || id = 11 -- 4 5 6 7 (10 ,无穷)
        临键锁(next-key locks)：使用了范围查询，不仅命中了record记录，还包含了gap间隙，这种情况下就是用临建锁，是mysql默认的行锁算法-相当于记录锁加上间隙锁
            临键锁 相当于 记录锁加间隙锁
            等值查询到一条记录的时候退化成记录锁。
            没匹配到任何记录的时候，退化成间隙锁
                 id > 5 and id < 10  -- 4 5 6 7 10
                临建锁锁住下一个左开右闭区间的区间 ----- 为了解决幻读的问题。
```

为什么innoDB的RR能解决幻读问题（语音作业）<br>

```text
四大隔离级别：
    RU(Read Uncommitted) 未提交读   - [脏读,不可重复读,幻读]
        不加锁
    RC(Read Committed) 已提交读     - [不可重复读,幻读]
        普通的select的快照读 底层使用MVCC实现
        加锁的select都是使用record lock没有gap lock、next ky lock
    RR（Repeatable Read） 可重复读   - [幻读(innodb解决了)]
        普通的select的快照读 底层使用MVCC实现
        加锁的select或者update delete使用的是当前读，底层使用record lock、gap lock、next ky lock
    Serializable 串行话
        所有select语句都会隐式转换为select in share mode共享锁阻塞其他事务的修改，会和update、delete互斥

解决读一致性的问题，总体由两大类方案,innodb采用mvcc解决了RR隔离级别的幻读问题
LBCC（lock Based concurrency Control）
    读取数据的时候基于锁，去锁住要操作的数据，不允许其他事务修改。如果只是基于锁意味着不支持并发，我们大多数时候都是读多写少，影响效率
MVCC（multi version concurrency control） 多版本并发控制
    MVCC可以看见这个事务之前已经存在的数据，甚至后面被修改或被删除；在这个事务之后的数据是看不到的，也叫快照
    原理：
        innodb为每个记录都实现了两个隐藏字段
            - DB_TRX_ID 6字节 事务ID 数据是在哪个事务插入或修改为新数据的就记录当前事务ID
            - DB_ROLL_PTR 7字节 回滚指针（删除版本号） 数据被删除或记录为旧数据的时候记录当前事务ID 没有修改或删除时候是空
                DB_ROLL_PTR其实是指向undo log链的指针
    MVCC查找规则：只能查找创建时间小于等于当前事务id 和删除时间大于当前事务id的行或者为空（未删除）
 
```

```text
innodb的行锁是通过锁住索引来实现的
如果表没有索引，怎么办？
    定义主键会选择主键作为聚集索引
    没有显示的定义会选择包含null的唯一索引作为主键索引
    没有这样的话innodb会内置6字节长的rowid作为隐藏的聚集索引
```

说下你对innoDB事务的理解！事务并发带来什么问题？怎么解决？（语音作业）<br>

```text
事务并发读一致性的问题，也就是说在一个事务中前后两次的查询不一致
事务并发导致的三大问题：
脏读：一个事务读到了其他事务未提交的数据导致前后两次读取的数据不一致
不可重复读：一个事务读取到了其他事务已提交的数据 （修改或删除造成的读不一致）
幻读：一个事务进行范围查询时，其他事务进行了插入已提交事务，多冒出来数据，造成事务中两次查询数据不一致（插入造成的读不一致）

读一致性是靠数据库的隔离级别来解决的

sql92定义了隔离级别
    
```
